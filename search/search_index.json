{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RouteML","text":""},{"location":"#installation","title":"Installation","text":"<p>To get started with RouteML, follow these installation instructions:</p> <ol> <li>Ensure you have Python and pip installed on your system.</li> <li>Open a terminal or command prompt.</li> <li>Run the following command to install RouteML:</li> </ol> <pre><code>pip install routeml\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Once you have installed RouteML, you can explore the functionality and usage by referring to the unit and integration tests located in the <code>tests</code> folder. These tests provide examples and demonstrate various features of the library.</p> <p>Additionally, you may find it helpful to visualize the Vehicle Routing Problem (VRP) routes. You can refer to the image below for an example:</p> <p></p> <p>This image showcases a solution for the VRP route.</p>"},{"location":"draw/","title":"Documentation for <code>routeml.draw</code>","text":""},{"location":"draw/#routeml.draw","title":"<code>routeml.draw</code>","text":""},{"location":"draw/#routeml.draw.plot_routes","title":"<code>plot_routes(routes, node_coords, save_path)</code>","text":"<p>Plot the routes on a 2D plane.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>A list of routes, where each route is a list of node IDs.</p> required <code>node_coords</code> <code>dict</code> <p>A dictionary of node coordinates, where the key is the node ID and the value is a tuple of the x and y coordinates.</p> required <code>save_path</code> <code>str</code> <p>The path to save the plot to.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>routeml/draw.py</code> <pre><code>def plot_routes(routes, node_coords, save_path):\n\"\"\"\n    Plot the routes on a 2D plane.\n\n    Args:\n        routes (list): A list of routes, where each route is a list of node IDs.\n        node_coords (dict): A dictionary of node coordinates, where the key is\n            the node ID and the value is a tuple of the x and y coordinates.\n        save_path (str): The path to save the plot to.\n\n    Returns:\n        None\n    \"\"\"\n    # Create a list of unique colors for each route\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n\n    # Plot each route with a different color\n    for i, route in enumerate(routes):\n        x = [node_coords[node][0] for node in route]\n        y = [node_coords[node][1] for node in route]\n        plt.plot(x, y, 'o-', color=colors[i % len(colors)])\n\n    # Plot the depot node with an X\n    depot_x, depot_y = node_coords[0]\n    plt.plot(depot_x, depot_y, 'rx', markersize=10, label='Depot')\n\n    plt.xlabel('X')\n    plt.ylabel('Y')\n    plt.title('Routes')\n    plt.savefig(save_path)\n    plt.close()\n</code></pre>"},{"location":"solvers/","title":"Documentation for <code>routeml.solvers</code>","text":""},{"location":"solvers/#routeml.solvers","title":"<code>routeml.solvers</code>","text":""},{"location":"solvers/#routeml.solvers.hgs_solve","title":"<code>hgs_solve(coords, demands, capacity, time_limit=5)</code>","text":"<p>coords: a numpy array of coordinates, where each row represents the x and y coordinates of a node demands: a numpy array of demands, where index 0 represents the demand of the depot (0) capacity: integer, capacity of all vehicles time_limit: integer, maximum time limit for the solver in seconds</p> Source code in <code>routeml/solvers.py</code> <pre><code>def hgs_solve(coords, demands, capacity, time_limit=5):\n\"\"\"\n    coords: a numpy array of coordinates, where each row represents the x and y coordinates of a node\n    demands: a numpy array of demands, where index 0 represents the demand of the depot (0)\n    capacity: integer, capacity of all vehicles\n    time_limit: integer, maximum time limit for the solver in seconds\n    \"\"\"\n\n    n = len(coords)\n    x = coords[:, 0]\n    y = coords[:, 1]\n\n    # Solver initialization\n    ap = hgs.AlgorithmParameters(timeLimit=time_limit)\n    hgs_solver = hgs.Solver(parameters=ap, verbose=False)\n\n    # Data preparation\n    data = dict()\n    data['x_coordinates'] = x\n    data['y_coordinates'] = y\n    data['distance_matrix'] = distance_matrix(coords, coords)\n    data['service_times'] = np.zeros(n)\n    data['demands'] = demands\n    data['vehicle_capacity'] = capacity\n    data['num_vehicles'] = 100  # Update with the appropriate number of vehicles\n    data['depot'] = 0\n\n    result = hgs_solver.solve_cvrp(data)\n    return result\n</code></pre>"},{"location":"utils/","title":"Documentation for <code>routeml.utils</code>","text":""},{"location":"utils/#routeml.utils","title":"<code>routeml.utils</code>","text":""},{"location":"utils/#routeml.utils.add_depot_to_routes","title":"<code>add_depot_to_routes(routes)</code>","text":"<p>Adds the depot node to the beginning and end of each route.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes, where each route is a list of nodes.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of routes, where each route is a list of nodes, with the depot added.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If routes is not a list or a nested list.</p> Source code in <code>routeml/utils.py</code> <pre><code>def add_depot_to_routes(routes):\n\"\"\"\n    Adds the depot node to the beginning and end of each route.\n\n    Args:\n        routes (list): List of routes, where each route is a list of nodes.\n\n    Returns:\n        list: List of routes, where each route is a list of nodes, with the depot added.\n\n    Raises:\n        ValueError: If routes is not a list or a nested list.\n    \"\"\"\n    if not isinstance(routes, list):\n        raise ValueError(\"Routes must be a list\")\n\n    for route in routes:\n        if not isinstance(route, list):\n            raise ValueError(\"Routes must be a nested list\")\n\n        route.insert(0, 0)\n        route.append(0)\n\n    return routes\n</code></pre>"},{"location":"utils/#routeml.utils.column_normalize_adjacency_matrix","title":"<code>column_normalize_adjacency_matrix(adj_matrix)</code>","text":"<p>Normalize an adjacency matrix by column.</p> <p>Parameters:</p> Name Type Description Default <code>adj_matrix</code> <code>np.ndarray</code> <p>Binary adjacency matrix.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Normalized adjacency matrix.</p> Source code in <code>routeml/utils.py</code> <pre><code>def column_normalize_adjacency_matrix(adj_matrix):\n\"\"\"\n    Normalize an adjacency matrix by column.\n\n    Args:\n        adj_matrix (np.ndarray): Binary adjacency matrix.\n\n    Returns:\n        np.ndarray: Normalized adjacency matrix.\n    \"\"\"\n    col_sums = np.sum(adj_matrix, axis=0)\n    normalized_matrix = adj_matrix / col_sums[np.newaxis, :]\n    return normalized_matrix\n</code></pre>"},{"location":"utils/#routeml.utils.get_cvrp_cost","title":"<code>get_cvrp_cost(routes_or_solution, coordinates, uchoa=False)</code>","text":"<p>Compute the total cost of a CVRP solution.</p> <p>Parameters:</p> Name Type Description Default <code>routes_or_solution</code> <code>list or solution</code> <p>List of routes or a solution.</p> required <code>coordinates</code> <code>np.array</code> <p>Array of node coordinates with shape (n_nodes, 2).</p> required <code>uchoa</code> <code>bool</code> <p>Whether to round the distances to the nearest integer. Follows the 2014 paper.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Total cost of the CVRP solution.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_cvrp_cost(routes_or_solution, coordinates, uchoa=False):\n\"\"\"\n    Compute the total cost of a CVRP solution.\n\n    Args:\n        routes_or_solution (list or solution): List of routes or a solution.\n        coordinates (np.array): Array of node coordinates with shape (n_nodes, 2).\n        uchoa (bool): Whether to round the distances to the nearest integer. Follows the 2014 paper.\n\n    Returns:\n        float: Total cost of the CVRP solution.\n    \"\"\"\n    if isinstance(routes_or_solution, list) and isinstance(routes_or_solution[0], list):\n        solution = routes_to_solution(routes_or_solution)\n    elif isinstance(routes_or_solution, list):\n        solution = routes_or_solution\n    else:\n        raise ValueError(\"Invalid input. Expected a nested list of routes or a solution.\")\n\n    total_cost = 0.0\n    for i in range(len(solution) - 1):\n        node1 = solution[i]\n        node2 = solution[i + 1]\n        coord1 = coordinates[node1]\n        coord2 = coordinates[node2]\n        distance = math.dist(coord1, coord2)\n        if uchoa:\n            distance = round(distance)\n        total_cost += distance\n\n    return total_cost\n</code></pre>"},{"location":"utils/#routeml.utils.get_cvrp_problem","title":"<code>get_cvrp_problem(num_nodes)</code>","text":"<p>Generate a random CVRP problem. Follows: \"https://arxiv.org/pdf/1802.04240.pdf\"</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>int</code> <p>Number of nodes in the problem. Excluding depot.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple containing the node coordinates (np.ndarray) and the demand (np.ndarray).</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_cvrp_problem(num_nodes):\n\"\"\"\n    Generate a random CVRP problem.\n    Follows: \"https://arxiv.org/pdf/1802.04240.pdf\"\n\n    Args:\n        num_nodes (int): Number of nodes in the problem. Excluding depot.\n\n    Returns:\n        tuple: Tuple containing the node coordinates (np.ndarray) and the demand (np.ndarray).\n    \"\"\"\n    # Generate depot\n    depot_id = 0\n    depot_coords = np.array([random.uniform(0, 1), random.uniform(0, 1)])\n    depot_demand = np.array([0])\n\n    # Generate node coordinates array\n    node_coords = np.empty((num_nodes + 1, 2))\n    node_coords[depot_id] = depot_coords\n\n    # Generate demand array\n    demands = np.empty((num_nodes + 1))\n    demands[depot_id] = depot_demand\n\n    # Generate node coordinates and demand\n    for node_id in range(1, num_nodes + 1):\n        x = random.uniform(0, 1)\n        y = random.uniform(0, 1)\n        demand_val = random.randint(1, 9)\n        node_coords[node_id] = np.array([float(x), float(y)])\n        demands[node_id] = int(demand_val)\n\n    return node_coords, demands\n</code></pre>"},{"location":"utils/#routeml.utils.get_random_solution","title":"<code>get_random_solution(N)</code>","text":"<p>Generates a random CVRP solution. Mostly for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of nodes in the problem. Excluding depot.</p> required <p>Returns:</p> Name Type Description <code>lst</code> <code>list</code> <p>List containing the solution.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_random_solution(N):\n\"\"\"\n    Generates a random CVRP solution. Mostly for debugging purposes.\n\n    Args:\n        N (int): Number of nodes in the problem. Excluding depot.\n\n    Returns:\n        lst (list): List containing the solution.\n    \"\"\"\n    # Generate a random list from 0 to N\n    lst = list(range(N + 1))\n\n    # Insert 0 at the end\n    lst.append(0)\n\n    # Randomly insert 1 to 5 zeros in between\n    num_zeros = random.randint(1, 5)\n    for _ in range(num_zeros):\n        index = random.randint(1, len(lst) - 1)  # Select a random index between 1 and len(lst)-1\n        while lst[index] == 0 or lst[index-1] == 0:\n            index = random.randint(1, len(lst) - 1)  # Select a new index if adjacent elements are already 0\n        lst.insert(index, 0)\n\n    return lst\n</code></pre>"},{"location":"utils/#routeml.utils.get_route_demand","title":"<code>get_route_demand(routes, demand)</code>","text":"<p>Compute the demand of each route.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes.</p> required <p>Returns:</p> Name Type Description <code>route_demand</code> <code>list</code> <p>List containing the demand of each route.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_route_demand(routes, demand):\n\"\"\"\n    Compute the demand of each route.\n\n    Args:\n        routes (list): List of routes.\n\n    Returns:\n        route_demand (list): List containing the demand of each route.\n    \"\"\"\n    route_demands = []\n    for route in routes:\n        route_demand = 0\n        for node in route:\n            try:\n                route_demand += demand[node]\n            except KeyError:\n                raise Exception(f\"Node {node} not found in the demand dictionary\")\n        route_demands.append(route_demand)\n    return route_demands\n</code></pre>"},{"location":"utils/#routeml.utils.get_submatrix","title":"<code>get_submatrix(indices, matrix, new_shape)</code>","text":"<p>Gets a submatrix from a matrix and pads it to the right and bottom with zeros.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <p>the indices to index on the matrix.</p> required <code>matrix</code> <p>the input matrix to index.</p> required <code>new_shape</code> <p>the desired shape after padding.</p> required <p>Returns:</p> Type Description <p>returns the submatrix after indexing and padding.</p> <pre><code>import numpy as np\nmatrix = np.arange(10).reshape(2, 5)\nindices = [1, 2, 3]\narray([[1, 2, 3, 0, 0, 0],\n       [6, 7, 8, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0]])\n</code></pre> Source code in <code>routeml/utils.py</code> <pre><code>def get_submatrix(indices, matrix, new_shape):\n\"\"\"\n    Gets a submatrix from a matrix and pads it to the right and bottom with zeros.\n\n    Args:\n        indices: the indices to index on the matrix.\n        matrix: the input matrix to index.\n        new_shape: the desired shape after padding.\n\n    Returns:\n        returns the submatrix after indexing and padding.\n\n    ```python\n    import numpy as np\n    matrix = np.arange(10).reshape(2, 5)\n    indices = [1, 2, 3]\n    array([[1, 2, 3, 0, 0, 0],\n           [6, 7, 8, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0]])\n    ```\n    \"\"\"\n    submatrix = matrix[:, indices]\n    return pad_matrix(submatrix, new_shape)\n</code></pre>"},{"location":"utils/#routeml.utils.is_feasible","title":"<code>is_feasible(routes, demand, capacity)</code>","text":"<p>Check if a CVRP solution is feasible.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes.</p> required <code>demand</code> <code>dict</code> <p>Dictionary containing node IDs as keys and corresponding demand as values.</p> required <code>capacity</code> <code>int</code> <p>Vehicle capacity.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the solution is feasible, False otherwise.</p> Source code in <code>routeml/utils.py</code> <pre><code>def is_feasible(routes, demand, capacity):\n\"\"\"\n    Check if a CVRP solution is feasible.\n\n    Args:\n        routes (list): List of routes.\n        demand (dict): Dictionary containing node IDs as keys and corresponding demand as values.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        bool: True if the solution is feasible, False otherwise.\n    \"\"\"\n    # Convert routes to a single solution\n    solution = routes_to_solution(routes)\n\n    # Check if each node appears only once\n    if set(solution) != set(demand.keys()):\n        return False\n\n    # Compute the demand for each route\n    for route in routes:\n        total_demand = sum(demand[node] for node in route)\n        if total_demand &gt; capacity:\n            return False\n\n    return True\n</code></pre>"},{"location":"utils/#routeml.utils.pad_matrix","title":"<code>pad_matrix(matrix, new_shape)</code>","text":"<p>Pads a matrix to the right and bottom with zeros.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <p>the input matrix to pad.</p> required <code>new_shape</code> <p>the desired shape after padding.</p> required <p>Returns:</p> Type Description <p>returns the padded matrix.</p> <pre><code>import numpy as np\nmatrix = np.arange(10).reshape(2, 5)\npad_matrix(matrix, (3, 6))\narray([[0, 1, 2, 3, 4, 0],\n       [5, 6, 7, 8, 9, 0],\n       [0, 0, 0, 0, 0, 0]])\n</code></pre> Source code in <code>routeml/utils.py</code> <pre><code>def pad_matrix(matrix, new_shape):\n\"\"\"\n    Pads a matrix to the right and bottom with zeros.\n\n    Args:\n        matrix: the input matrix to pad.\n        new_shape: the desired shape after padding.\n\n    Returns:\n        returns the padded matrix.\n\n    ```python\n    import numpy as np\n    matrix = np.arange(10).reshape(2, 5)\n    pad_matrix(matrix, (3, 6))\n    array([[0, 1, 2, 3, 4, 0],\n           [5, 6, 7, 8, 9, 0],\n           [0, 0, 0, 0, 0, 0]])\n    ```\n    \"\"\"\n    assert len(new_shape) == len(matrix.shape), \"new_shape and matrix dimensions must match\"\n    padding = [(0, new_dim - old_dim) if new_dim &gt; old_dim else (0, 0) for old_dim, new_dim in zip(matrix.shape, new_shape)]\n    return np.pad(matrix, padding, 'constant')\n</code></pre>"},{"location":"utils/#routeml.utils.parse_vrplib_file","title":"<code>parse_vrplib_file(source)</code>","text":"<p>Parses a VRPLIB file and returns a dictionary with the following keys: - name: Name of the problem. - comment: Comment of the problem. - type: Type of the problem. - dimension: Number of nodes. - edge_weight_type: Type of edge weight. - capacity: Capacity of the vehicles. - node_coords: Dict of node coordinates. - demand: Dict of node demands. - depot_ids: List of depot IDs.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>URL or path to the VRPLIB file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary with the parsed data.</p> Source code in <code>routeml/utils.py</code> <pre><code>def parse_vrplib_file(source):\n\"\"\"\n    Parses a VRPLIB file and returns a dictionary with the following keys:\n    - name: Name of the problem.\n    - comment: Comment of the problem.\n    - type: Type of the problem.\n    - dimension: Number of nodes.\n    - edge_weight_type: Type of edge weight.\n    - capacity: Capacity of the vehicles.\n    - node_coords: Dict of node coordinates.\n    - demand: Dict of node demands.\n    - depot_ids: List of depot IDs.\n\n    Args:\n        source (str): URL or path to the VRPLIB file.\n\n    Returns:\n        dict: Dictionary with the parsed data.\n    \"\"\"\n    if source.startswith('http://') or source.startswith('https://'):\n        response = requests.get(source)\n        content = response.text\n    else:\n        with open(source, 'r') as file:\n            content = file.read()\n\n    data = {}\n\n    # Extracting problem information using regex\n    name_match = re.search(r'NAME\\s*:\\s*(\\S+)', content)\n    if name_match:\n        data['name'] = name_match.group(1)\n\n    comment_match = re.search(r'COMMENT\\s*:\\s*\"(.+)\"', content)\n    if comment_match:\n        data['comment'] = comment_match.group(1)\n\n    type_match = re.search(r'TYPE\\s*:\\s*(\\S+)', content)\n    if type_match:\n        data['type'] = type_match.group(1)\n\n    dimension_match = re.search(r'DIMENSION\\s*:\\s*(\\d+)', content)\n    if dimension_match:\n        data['dimension'] = int(dimension_match.group(1))\n\n    edge_weight_type_match = re.search(r'EDGE_WEIGHT_TYPE\\s*:\\s*(\\S+)', content)\n    if edge_weight_type_match:\n        data['edge_weight_type'] = edge_weight_type_match.group(1)\n\n    capacity_match = re.search(r'CAPACITY\\s*:\\s*(\\d+)', content)\n    if capacity_match:\n        data['capacity'] = int(capacity_match.group(1))\n\n    node_coords_match = re.search(r'NODE_COORD_SECTION\\s*(.+?)\\s*DEMAND_SECTION', content, re.DOTALL)\n    if node_coords_match:\n        node_coords_str = node_coords_match.group(1).strip()\n        node_coords = []\n        for line in node_coords_str.split('\\n'):\n            node_id, x, y = re.findall(r'(\\d+)\\s+([-+]?\\d*\\.?\\d+)\\s+([-+]?\\d*\\.?\\d+)', line)[0]\n            node_coords.append([float(x), float(y)])\n        data['node_coords'] = np.array(node_coords)\n\n    # Extracting demand information\n    demand_section_match = re.search(r'DEMAND_SECTION\\s*(.+?)\\s*DEPOT_SECTION', content, re.DOTALL)\n    if demand_section_match:\n        demand_section_str = demand_section_match.group(1).strip()\n        demand = []\n        for line in demand_section_str.split('\\n'):\n            node_id, demand_val = re.findall(r'(\\d+)\\s+(-?\\d+)', line)[0]\n            demand.append(int(demand_val))\n        data['demand'] = np.array(demand)\n\n    # Extracting depot information\n    depot_section_match = re.search(r'DEPOT_SECTION\\s*(.+?)\\s*EOF', content, re.DOTALL)\n    if depot_section_match:\n        depot_section_str = depot_section_match.group(1).strip()\n        depot_ids = [int(node_id) for node_id in re.findall(r'(\\d+)\\s*[^-0-9]', depot_section_str)]\n        data['depot_ids'] = depot_ids\n\n    return data\n</code></pre>"},{"location":"utils/#routeml.utils.parse_vrplib_solution","title":"<code>parse_vrplib_solution(source)</code>","text":"<p>Parses a solution file from the VRPLIB website and returns the routes and cost.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to the solution file or URL to the solution file.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple containing the routes (list of lists) and the cost (float).</p> Source code in <code>routeml/utils.py</code> <pre><code>def parse_vrplib_solution(source):\n\"\"\"\n    Parses a solution file from the VRPLIB website and returns the routes and cost.\n\n    Args:\n        source (str): Path to the solution file or URL to the solution file.\n\n    Returns:\n        tuple: Tuple containing the routes (list of lists) and the cost (float).\n    \"\"\"\n    route_regex = re.compile(r'Route #(\\d+): (.+)')\n    cost_regex = re.compile(r'Cost ([\\d.]+)')\n\n    if source.startswith('http://') or source.startswith('https://'):\n        response = requests.get(source)\n        solution_text = response.text\n    else:\n        with open(source, 'r') as file:\n            solution_text = file.read()\n\n    routes = []\n    cost = None\n\n    lines = solution_text.strip().split('\\n')\n    for line in lines:\n        route_match = route_regex.match(line)\n        if route_match:\n            route_number = int(route_match.group(1))\n            nodes = list(map(int, route_match.group(2).split()))\n            routes.append(nodes)\n\n        cost_match = cost_regex.match(line)\n        if cost_match:\n            cost = float(cost_match.group(1))\n\n    return routes, cost\n</code></pre>"},{"location":"utils/#routeml.utils.routes_to_solution","title":"<code>routes_to_solution(routes)</code>","text":"<p>Converts a list of routes into a solution (list of routes).</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes, where each route is a list of nodes.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Solution (list of routes).</p> Source code in <code>routeml/utils.py</code> <pre><code>def routes_to_solution(routes):\n\"\"\"\n    Converts a list of routes into a solution (list of routes).\n\n    Args:\n        routes (list): List of routes, where each route is a list of nodes.\n\n    Returns:\n        list: Solution (list of routes).\n    \"\"\"\n    solution = []\n    for i, route in enumerate(routes):\n        assert route[0] == 0\n        assert route[-1] == 0\n        # Skip depot node for all routes except the first one\n        if i &gt; 0:\n            route = route[1:]\n        solution += route\n    return solution\n</code></pre>"},{"location":"utils/#routeml.utils.solution_to_adjacency_matrix","title":"<code>solution_to_adjacency_matrix(cvrp_solution)</code>","text":"<p>Converts a CVRP solution into a symmetric adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>cvrp_solution</code> <code>list</code> <p>CVRP solution (list of nodes).</p> required <p>Returns:</p> Type Description <p>np.ndarray: Symmetric adjacency matrix.</p> Source code in <code>routeml/utils.py</code> <pre><code>def solution_to_adjacency_matrix(cvrp_solution):\n\"\"\"\n    Converts a CVRP solution into a symmetric adjacency matrix.\n\n    Args:\n        cvrp_solution (list): CVRP solution (list of nodes).\n\n    Returns:\n        np.ndarray: Symmetric adjacency matrix.\n    \"\"\"\n    num_nodes = max(cvrp_solution) + 1\n    matrix = np.zeros((num_nodes, num_nodes))\n\n    for i in range(len(cvrp_solution) - 1):\n        matrix[cvrp_solution[i]][cvrp_solution[i + 1]] = 1\n        matrix[cvrp_solution[i + 1]][cvrp_solution[i]] = 1\n    return matrix\n</code></pre>"},{"location":"utils/#routeml.utils.solution_to_routes","title":"<code>solution_to_routes(solution)</code>","text":"<p>Converts a solution (list of nodes) into a list of routes.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>list</code> <p>Solution (list of nodes).</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of routes, where each route is a list of nodes.</p> Source code in <code>routeml/utils.py</code> <pre><code>def solution_to_routes(solution):\n\"\"\"\n    Converts a solution (list of nodes) into a list of routes.\n\n    Args:\n        solution (list): Solution (list of nodes).\n\n    Returns:\n        list: List of routes, where each route is a list of nodes.\n    \"\"\"\n    routes = []\n    route = []\n    for node in solution:\n        if node == 0 and route:\n            route.append(0)\n            routes.append(route)\n            route = []\n        route.append(node)\n    return routes\n</code></pre>"}]}