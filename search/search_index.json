{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RouteML","text":""},{"location":"#installation","title":"Installation","text":"<p>To get started with RouteML, follow these installation instructions:</p> <ol> <li>Ensure you have Python and pip installed on your system.</li> <li>Open a terminal or command prompt.</li> <li>Run the following command to install RouteML:</li> </ol> <pre><code>pip install routeml\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Once you have installed RouteML, you can explore the functionality and usage by referring to the unit and integration tests located in the <code>tests</code> folder. These tests provide examples and demonstrate various features of the library.</p> <p>Additionally, you may find it helpful to visualize the Vehicle Routing Problem (VRP) routes. You can refer to the image below for an example:</p> <p></p> <p>This image showcases a solution for the VRP route.</p>"},{"location":"draw/","title":"Documentation for <code>routeml.draw</code>","text":""},{"location":"draw/#routeml.draw","title":"<code>routeml.draw</code>","text":""},{"location":"draw/#routeml.draw.concatenate_images","title":"<code>concatenate_images(image_paths, grid_size, save_path='test.png')</code>","text":"<p>Concatenate a list of images into a grid.</p> <p>Parameters:</p> Name Type Description Default <code>image_paths</code> <code>list</code> <p>A list of image paths.</p> required <code>grid_size</code> <code>tuple</code> <p>A tuple of the number of rows and columns in the grid.</p> required <code>save_path</code> <code>str</code> <p>The path to save the concatenated image to.</p> <code>'test.png'</code> <p>Returns:</p> Name Type Description <code>save_path</code> <code>str</code> <p>The path to the saved image.</p> Source code in <code>routeml/draw.py</code> <pre><code>def concatenate_images(image_paths, grid_size, save_path=\"test.png\"):\n\"\"\"\n    Concatenate a list of images into a grid.\n\n    Args:\n        image_paths (list): A list of image paths.\n        grid_size (tuple): A tuple of the number of rows and columns in the grid.\n        save_path (str): The path to save the concatenated image to.\n\n    Returns:\n        save_path (str): The path to the saved image.\n    \"\"\"\n    num_images = len(image_paths)\n    grid_rows, grid_cols = grid_size\n\n    # Open and load all images\n    images = [Image.open(path) for path in image_paths]\n\n    # Determine the size of each image\n    image_width, image_height = images[0].size\n\n    # Create an empty grid canvas\n    grid_width = image_width * grid_cols\n    grid_height = image_height * grid_rows\n    grid = Image.new('RGB', (grid_width, grid_height))\n\n    # Paste each image onto the grid\n    for i, image in enumerate(images):\n        row = i // grid_cols\n        col = i % grid_cols\n        x = col * image_width\n        y = row * image_height\n        grid.paste(image, (x, y))\n\n    # # Display the concatenated image\n    # grid.show()\n\n    # Save the concatenated image\n    grid.save(save_path)\n</code></pre>"},{"location":"draw/#routeml.draw.plot_dmatrix_heatmap","title":"<code>plot_dmatrix_heatmap(distance_matrix, cmap='Blues_r', save_path='heatmap.png')</code>","text":"<p>Given a distance matrix, creates a heatmap and saves the plot to a specified location.</p> <p>Parameters:</p> Name Type Description Default <code>distance_matrix</code> <code>numpy.ndarray</code> <p>A symmetric matrix containing distances between nodes.</p> required <code>save_path</code> <code>str</code> <p>Path where the heatmap will be saved.</p> <code>'heatmap.png'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>routeml/draw.py</code> <pre><code>def plot_dmatrix_heatmap(distance_matrix, cmap=\"Blues_r\", save_path=\"heatmap.png\"):\n\"\"\"\n    Given a distance matrix, creates a heatmap and saves the plot to a specified location.\n\n    Parameters:\n        distance_matrix (numpy.ndarray): A symmetric matrix containing distances between nodes.\n        save_path (str): Path where the heatmap will be saved.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Create figure with specified DPI\n    fig = plt.figure(figsize=(fig_width_pixels / dpi, fig_height_pixels / dpi), dpi=dpi)\n\n    # Plot Heatmap\n    # cmap_options = [\"Greys\", \"YlGnBu\", \"YlOrRd\", \"BuPu\", \"Greens\", \"Purples\", \"Blues\", \"Oranges\", \"Reds\"]\n    sns.heatmap(distance_matrix, cmap=cmap)\n    plt.title('Heatmap of Pairwise Distances')\n    plt.xlabel('Node')\n    plt.ylabel('Node')\n\n    # Save and close figure\n    plt.savefig(save_path)\n    plt.close(fig)\n</code></pre>"},{"location":"draw/#routeml.draw.plot_dmatrix_histogram","title":"<code>plot_dmatrix_histogram(distance_matrix, save_path='histogram.png')</code>","text":"<p>Given a symmetric distance matrix, creates a histogram of distances and saves the plot to a specified location.</p> <p>Parameters:</p> Name Type Description Default <code>distance_matrix</code> <code>numpy.ndarray</code> <p>A symmetric matrix containing distances between nodes.</p> required <code>save_path</code> <code>str</code> <p>Path where the histogram will be saved.</p> <code>'histogram.png'</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>routeml/draw.py</code> <pre><code>def plot_dmatrix_histogram(distance_matrix, save_path=\"histogram.png\"):\n\"\"\"\n    Given a symmetric distance matrix, creates a histogram of distances and saves the plot to a specified location.\n\n    Parameters:\n        distance_matrix (numpy.ndarray): A symmetric matrix containing distances between nodes.\n        save_path (str): Path where the histogram will be saved.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Get upper triangle of the distance matrix\n    dists_upper = distance_matrix[np.triu_indices(distance_matrix.shape[0], k=1)]\n\n    # Create figure with specified DPI\n    fig = plt.figure(figsize=(fig_width_pixels / dpi, fig_height_pixels / dpi), dpi=dpi)\n\n    # Plot Histogram\n    plt.hist(dists_upper, bins=30)\n    plt.title('Distribution of Pairwise Distances')\n    plt.xlabel('Distance')\n    plt.ylabel('Frequency')\n\n    # Save and close figure\n    plt.savefig(save_path)\n    plt.close(fig)\n</code></pre>"},{"location":"draw/#routeml.draw.plot_embeddings","title":"<code>plot_embeddings(routes, embeddings, save_path='test.png')</code>","text":"<p>Plot the embeddings in 2D space.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>A list of routes, where each route is a list of node IDs.</p> required <code>embeddings</code> <code>np.ndarray</code> <p>A 2D array of embeddings, where each row is an embedding vector.</p> required <p>Returns:</p> Name Type Description <code>save_path</code> <code>str</code> <p>The path to the saved plot.</p> Source code in <code>routeml/draw.py</code> <pre><code>def plot_embeddings(routes, embeddings, save_path=\"test.png\"):\n\"\"\"\n    Plot the embeddings in 2D space.\n\n    Args:\n        routes (list): A list of routes, where each route is a list of node IDs.\n        embeddings (np.ndarray): A 2D array of embeddings, where each row is an\n            embedding vector.\n\n    Returns:\n        save_path (str): The path to the saved plot.\n    \"\"\"\n    fig = plt.figure(figsize=(fig_width_pixels / dpi, fig_height_pixels / dpi), dpi=dpi)\n\n    # Colors\n    colors = get_colors(len(routes))\n\n    # Perform t-SNE dimensionality reduction\n    tsne = TSNE(n_components=2, random_state=42)\n    embeddings_2d = tsne.fit_transform(embeddings)\n\n    # Initialize lists to store x and y coordinates for each class\n    x_coords_list = []\n    y_coords_list = []\n\n    # Split the 2D embeddings based on the number of samples in each class\n    for route in routes:\n        # Extract x and y coordinates for the current class\n        x_coords = embeddings_2d[route, 0]\n        y_coords = embeddings_2d[route, 1]\n\n        # Append the coordinates to the lists\n        x_coords_list.append(x_coords)\n        y_coords_list.append(y_coords)\n\n    # Plot the embeddings for each class\n    for idx, (x_coords, y_coords) in enumerate(zip(x_coords_list, y_coords_list)):\n        plt.scatter(x_coords, y_coords, marker='.', color=colors[idx])\n    x_coords = embeddings_2d[0, 0]\n    y_coords = embeddings_2d[0, 1]\n    plt.scatter(x_coords, y_coords, marker='x', color='black', label='Depot')\n\n    plt.xlabel('Dimension 1')\n    plt.ylabel('Dimension 2')\n    plt.title('Embeddings in 2D Space')\n    # plt.legend()\n\n    # Save the plot as \"test.png\"\n    plt.savefig(save_path)\n    plt.close()\n    return save_path\n</code></pre>"},{"location":"draw/#routeml.draw.plot_routes","title":"<code>plot_routes(routes, node_coords, save_path, draw_lines=True, draw_linehauls=True)</code>","text":"<p>Plot the routes on a 2D plane.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>A list of routes, where each route is a list of node IDs.</p> required <code>node_coords</code> <code>dict</code> <p>A dictionary of node coordinates, where the key is the node ID and the value is a tuple of the x and y coordinates.</p> required <code>save_path</code> <code>str</code> <p>The path to save the plot to.</p> required <code>draw_lines</code> <code>bool</code> <p>Whether to draw lines between the nodes in each route.</p> <code>True</code> <code>draw_linehauls</code> <code>bool</code> <p>Whether to draw the linehauls in each route.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>save_path</code> <code>str</code> <p>The path to the saved plot.</p> Source code in <code>routeml/draw.py</code> <pre><code>def plot_routes(routes, node_coords, save_path, draw_lines=True, draw_linehauls=True):\n\"\"\"\n    Plot the routes on a 2D plane.\n\n    Args:\n        routes (list): A list of routes, where each route is a list of node IDs.\n        node_coords (dict): A dictionary of node coordinates, where the key is\n            the node ID and the value is a tuple of the x and y coordinates.\n        save_path (str): The path to save the plot to.\n        draw_lines (bool): Whether to draw lines between the nodes in each route.\n        draw_linehauls (bool): Whether to draw the linehauls in each route.\n\n    Returns:\n        save_path (str): The path to the saved plot.\n    \"\"\"\n    fig = plt.figure(figsize=(fig_width_pixels / dpi, fig_height_pixels / dpi), dpi=dpi)\n\n    # Create a list of unique colors for each route\n    colors = get_colors(len(routes))\n\n    # Plot each route with a different color\n    for i, route in enumerate(routes):\n        if not draw_linehauls:\n            route = route[1: -1]\n        x = [node_coords[node][0] for node in route]\n        y = [node_coords[node][1] for node in route]\n        if draw_lines:\n            plt.plot(x, y, 'o-', color=colors[i])\n        else:\n            plt.plot(x, y, 'o', color=colors[i])\n\n    # Plot the depot node with an X\n    depot_x, depot_y = node_coords[0]\n    plt.plot(depot_x, depot_y, 'kx', markersize=10, label='Depot')\n\n    plt.xlabel('X')\n    plt.ylabel('Y')\n    plt.title('Routes')\n    plt.savefig(save_path)\n    plt.close()\n    return save_path\n</code></pre>"},{"location":"solvers/","title":"Documentation for <code>routeml.solvers</code>","text":""},{"location":"solvers/#routeml.solvers","title":"<code>routeml.solvers</code>","text":""},{"location":"solvers/#routeml.solvers.hgs_solve","title":"<code>hgs_solve(coords, demands, capacity, subset=None, time_limit=5)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>coords</code> <p>a numpy array of coordinates, where each row represents the x and y coordinates of a node</p> required <code>demands</code> <p>a numpy array of demands, where index 0 represents the demand of the depot (0)</p> required <code>capacity</code> <p>integer, capacity of all vehicles</p> required <code>subset</code> <p>a subset of node IDs that we want to solve for</p> <code>None</code> <code>time_limit</code> <p>integer, maximum time limit for the solver in seconds</p> <code>5</code> <p>Returns:</p> Name Type Description <code>result</code> <p>a RoutingSolution from Python package Hygese with the following attributes: - cost: the total cost of the solution - time: the time taken to solve the problem - n_routes: the number of routes in the solution - routes: a list of routes, where each route is a list of node IDs, excluding the depots.</p> Source code in <code>routeml/solvers.py</code> <pre><code>def hgs_solve(coords, demands, capacity, subset=None, time_limit=5):\n\"\"\"\n    Args:\n        coords: a numpy array of coordinates, where each row represents the x and y coordinates of a node\n        demands: a numpy array of demands, where index 0 represents the demand of the depot (0)\n        capacity: integer, capacity of all vehicles\n        subset: a subset of node IDs that we want to solve for\n        time_limit: integer, maximum time limit for the solver in seconds\n\n    Returns:\n        result: a RoutingSolution from Python package Hygese with the following attributes:\n            - cost: the total cost of the solution\n            - time: the time taken to solve the problem\n            - n_routes: the number of routes in the solution\n            - routes: a list of routes, where each route is a list of node IDs, excluding the depots.\n    \"\"\"\n\n    if subset != None:\n        subset = sorted(subset)\n        coords = coords[subset]\n        demands = demands[subset]\n        index_to_node = {i: node for i, node in enumerate(subset)}\n\n    n = len(coords)\n    x = coords[:, 0]\n    y = coords[:, 1]\n\n    # Solver initialization\n    ap = hgs.AlgorithmParameters(timeLimit=time_limit)\n    hgs_solver = hgs.Solver(parameters=ap, verbose=False)\n\n    # Data preparation\n    data = dict()\n    data['x_coordinates'] = x\n    data['y_coordinates'] = y\n    data['distance_matrix'] = distance_matrix(coords, coords)\n    data['service_times'] = np.zeros(n)\n    data['demands'] = demands\n    data['vehicle_capacity'] = capacity\n    data['num_vehicles'] = 100  # Update with the appropriate number of vehicles\n    data['depot'] = 0\n\n    result = hgs_solver.solve_cvrp(data)\n    if subset != None:\n        result.routes = [[index_to_node[i] for i in route] for route in result.routes]\n    return result\n</code></pre>"},{"location":"solvers/#routeml.solvers.hgs_solve_subproblems","title":"<code>hgs_solve_subproblems(coords, demands, capacity, subsets, time_limit=5)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>coords</code> <p>a numpy array of coordinates, where each row represents the x and y coordinates of a node</p> required <code>demands</code> <p>a numpy array of demands, where index 0 represents the demand of the depot (0)</p> required <code>capacity</code> <p>integer, capacity of all vehicles</p> required <code>subsets</code> <p>a list of subsets of node IDs that we want to solve for</p> required <code>time_limit</code> <p>integer, maximum time limit for the solver in seconds</p> <code>5</code> <p>Returns:</p> Name Type Description <code>cost</code> <p>the total cost of the solution</p> <code>time</code> <p>the time taken to solve the problem</p> <code>n_routes</code> <p>the number of routes in the solution</p> <code>routes</code> <p>a list of routes, where each route is a list of node IDs, excluding the depots.</p> Source code in <code>routeml/solvers.py</code> <pre><code>def hgs_solve_subproblems(coords, demands, capacity, subsets, time_limit=5):\n\"\"\"\n    Args:\n        coords: a numpy array of coordinates, where each row represents the x and y coordinates of a node\n        demands: a numpy array of demands, where index 0 represents the demand of the depot (0)\n        capacity: integer, capacity of all vehicles\n        subsets: a list of subsets of node IDs that we want to solve for\n        time_limit: integer, maximum time limit for the solver in seconds\n\n    Returns:\n        cost: the total cost of the solution\n        time: the time taken to solve the problem\n        n_routes: the number of routes in the solution\n        routes: a list of routes, where each route is a list of node IDs, excluding the depots.\n    \"\"\"\n    with Pool() as p:\n        print(\"Using {} cores\".format(p._processes))\n        results = p.starmap(hgs_solve, [(coords, demands, capacity, subset, time_limit) for subset in subsets])\n        cost = sum(result.cost for result in results)\n        time = sum(result.time for result in results)\n        n_routes = sum(result.n_routes for result in results)\n        routes = [route for result in results for route in result.routes]\n    return cost, time, n_routes, routes\n</code></pre>"},{"location":"utils/","title":"Documentation for <code>routeml.utils</code>","text":""},{"location":"utils/#routeml.utils","title":"<code>routeml.utils</code>","text":""},{"location":"utils/#routeml.utils.add_depot_to_routes","title":"<code>add_depot_to_routes(routes)</code>","text":"<p>Adds the depot node to the beginning and end of each route.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes, where each route is a list of nodes.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of routes, where each route is a list of nodes, with the depot added.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If routes is not a list or a nested list.</p> Source code in <code>routeml/utils.py</code> <pre><code>def add_depot_to_routes(routes):\n\"\"\"\n    Adds the depot node to the beginning and end of each route.\n\n    Args:\n        routes (list): List of routes, where each route is a list of nodes.\n\n    Returns:\n        list: List of routes, where each route is a list of nodes, with the depot added.\n\n    Raises:\n        ValueError: If routes is not a list or a nested list.\n    \"\"\"\n    if not isinstance(routes, list):\n        raise ValueError(\"Routes must be a list\")\n\n    for route in routes:\n        if not isinstance(route, list):\n            raise ValueError(\"Routes must be a nested list\")\n\n        route.insert(0, 0)\n        route.append(0)\n\n    return routes\n</code></pre>"},{"location":"utils/#routeml.utils.column_normalize_adjacency_matrix","title":"<code>column_normalize_adjacency_matrix(adj_matrix)</code>","text":"<p>Normalize an adjacency matrix by column.</p> <p>Parameters:</p> Name Type Description Default <code>adj_matrix</code> <code>np.ndarray</code> <p>Binary adjacency matrix.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Normalized adjacency matrix.</p> Source code in <code>routeml/utils.py</code> <pre><code>def column_normalize_adjacency_matrix(adj_matrix):\n\"\"\"\n    Normalize an adjacency matrix by column.\n\n    Args:\n        adj_matrix (np.ndarray): Binary adjacency matrix.\n\n    Returns:\n        np.ndarray: Normalized adjacency matrix.\n    \"\"\"\n    col_sums = np.sum(adj_matrix, axis=0)\n    normalized_matrix = adj_matrix / col_sums[np.newaxis, :]\n    return normalized_matrix\n</code></pre>"},{"location":"utils/#routeml.utils.get_all_route_demands","title":"<code>get_all_route_demands(routes, demand)</code>","text":"<p>Compute the demand of each route.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes.</p> required <p>Returns:</p> Name Type Description <code>route_demand</code> <code>list</code> <p>List containing the demand of each route.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_all_route_demands(routes, demand):\n\"\"\"\n    Compute the demand of each route.\n\n    Args:\n        routes (list): List of routes.\n\n    Returns:\n        route_demand (list): List containing the demand of each route.\n    \"\"\"\n    route_demands = []\n    for route in routes:\n        route_demand = 0\n        for node in route:\n            try:\n                route_demand += demand[node]\n            except KeyError:\n                raise Exception(f\"Node {node} not found in the demand dictionary\")\n        route_demands.append(route_demand)\n    return route_demands\n</code></pre>"},{"location":"utils/#routeml.utils.get_cvrp_cost","title":"<code>get_cvrp_cost(routes_or_solution, coordinates, uchoa=False)</code>","text":"<p>Compute the total cost of a CVRP solution.</p> <p>Parameters:</p> Name Type Description Default <code>routes_or_solution</code> <code>list or solution</code> <p>List of routes or a solution.</p> required <code>coordinates</code> <code>np.array</code> <p>Array of node coordinates with shape (n_nodes, 2).</p> required <code>uchoa</code> <code>bool</code> <p>Whether to round the distances to the nearest integer. Follows the 2014 paper.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Total cost of the CVRP solution.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_cvrp_cost(routes_or_solution, coordinates, uchoa=False):\n\"\"\"\n    Compute the total cost of a CVRP solution.\n\n    Args:\n        routes_or_solution (list or solution): List of routes or a solution.\n        coordinates (np.array): Array of node coordinates with shape (n_nodes, 2).\n        uchoa (bool): Whether to round the distances to the nearest integer. Follows the 2014 paper.\n\n    Returns:\n        float: Total cost of the CVRP solution.\n    \"\"\"\n    if isinstance(routes_or_solution, list) and isinstance(routes_or_solution[0], list):\n        solution = routes_to_solution(routes_or_solution)\n    elif isinstance(routes_or_solution, list):\n        solution = routes_or_solution\n    else:\n        raise ValueError(\"Invalid input. Expected a nested list of routes or a solution.\")\n\n    total_cost = 0.0\n    for i in range(len(solution) - 1):\n        node1 = solution[i]\n        node2 = solution[i + 1]\n        coord1 = coordinates[node1]\n        coord2 = coordinates[node2]\n        distance = math.dist(coord1, coord2)\n        if uchoa:\n            distance = round(distance)\n        total_cost += distance\n\n    return total_cost\n</code></pre>"},{"location":"utils/#routeml.utils.get_cvrp_problem","title":"<code>get_cvrp_problem(num_nodes)</code>","text":"<p>Generate a random CVRP problem. Follows: \"https://arxiv.org/pdf/1802.04240.pdf\"</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>int</code> <p>Number of nodes in the problem. Excluding depot.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple containing the node coordinates (np.ndarray) and the demand (np.ndarray).</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_cvrp_problem(num_nodes):\n\"\"\"\n    Generate a random CVRP problem.\n    Follows: \"https://arxiv.org/pdf/1802.04240.pdf\"\n\n    Args:\n        num_nodes (int): Number of nodes in the problem. Excluding depot.\n\n    Returns:\n        tuple: Tuple containing the node coordinates (np.ndarray) and the demand (np.ndarray).\n    \"\"\"\n    # Generate depot\n    depot_id = 0\n    depot_coords = np.array([random.uniform(0, 1), random.uniform(0, 1)])\n    depot_demand = np.array([0])\n\n    # Generate node coordinates array\n    node_coords = np.empty((num_nodes + 1, 2))\n    node_coords[depot_id] = depot_coords\n\n    # Generate demand array\n    demands = np.empty((num_nodes + 1))\n    demands[depot_id] = depot_demand\n\n    # Generate node coordinates and demand\n    for node_id in range(1, num_nodes + 1):\n        x = random.uniform(0, 1)\n        y = random.uniform(0, 1)\n        demand_val = random.randint(1, 9)\n        node_coords[node_id] = np.array([float(x), float(y)])\n        demands[node_id] = int(demand_val)\n\n    return node_coords, demands\n</code></pre>"},{"location":"utils/#routeml.utils.get_graph_embedding","title":"<code>get_graph_embedding(src_key_padding_mask, node_emb)</code>","text":"<p>Given a source key padding mask and node embeddings, this function generates a graph embedding by summing  the embeddings at positions specified by the mask and normalizing by the number of nodes in the graph.</p> <p>The function works by inverting the src_key_padding_mask, adding an extra dimension to the mask to match  the node_emb's dimensions, and then extracts the node embeddings at the positions where mask is True.  The resulting embeddings are summed to obtain the graph embedding, which is then normalized by the number  of nodes in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>src_key_padding_mask</code> <code>torch.Tensor</code> <p>A binary tensor of shape (batch_size, length), </p> required <code>node_emb</code> <code>torch.Tensor</code> <p>A tensor of node embeddings of shape (batch_size, length, node_emb_size).</p> required <p>Returns:</p> Type Description <p>torch.Tensor: The graph embedding of shape (batch_size, node_emb_size). The embeddings are normalized </p> <p>by the number of nodes in the graph.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_graph_embedding(src_key_padding_mask, node_emb):\n\"\"\"\n    Given a source key padding mask and node embeddings, this function generates a graph embedding by summing \n    the embeddings at positions specified by the mask and normalizing by the number of nodes in the graph.\n\n    The function works by inverting the src_key_padding_mask, adding an extra dimension to the mask to match \n    the node_emb's dimensions, and then extracts the node embeddings at the positions where mask is True. \n    The resulting embeddings are summed to obtain the graph embedding, which is then normalized by the number \n    of nodes in the graph.\n\n    Args:\n        src_key_padding_mask (torch.Tensor): A binary tensor of shape (batch_size, length), \n        where 0 indicates the position of nodes and 1 otherwise.\n        node_emb (torch.Tensor): A tensor of node embeddings of shape (batch_size, length, node_emb_size).\n\n    Returns:\n        torch.Tensor: The graph embedding of shape (batch_size, node_emb_size). The embeddings are normalized \n        by the number of nodes in the graph.\n    \"\"\"\n    mask = ~src_key_padding_mask\n    if mask.sum() == 0:\n        raise ValueError(\"The src_key_padding_mask cannot be all 1s.\")\n    mask = mask.unsqueeze(2).expand_as(node_emb)\n    extracted_node_embs = node_emb * mask.float()\n    graph_emb = extracted_node_embs.sum(dim=1)\n    graph_emb = graph_emb / (~src_key_padding_mask).sum(dim=1).unsqueeze(1).float()\n    return graph_emb\n</code></pre>"},{"location":"utils/#routeml.utils.get_logit_mask","title":"<code>get_logit_mask(sol, demands, capacity)</code>","text":"<p>Gets a logit mask for a given solution. Note that this only takes a full solution.</p> <p>Parameters:</p> Name Type Description Default <code>sol</code> <code>list</code> <p>the solution to mask.</p> required <code>demands</code> <code>np.ndarray</code> <p>the demands of each node.</p> required <code>capacity</code> <code>int</code> <p>the capacity of the vehicle.</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>np.ndarray</code> <p>the logit mask.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_logit_mask(sol, demands, capacity):\n\"\"\"\n    Gets a logit mask for a given solution. Note that this only takes a full solution.\n\n    Args:\n        sol (list): the solution to mask.\n        demands (np.ndarray): the demands of each node.\n        capacity (int): the capacity of the vehicle.\n\n    Returns:\n        mask (np.ndarray): the logit mask.\n    \"\"\"\n    prob = set(sol)\n    mask = np.full((len(sol) - 1, len(prob)), 0.0) # mark all as valid\n    for i in range(len(sol) - 1): # NOTE this loop is 100% correct, don't change this.\n        # a is all nodes that I visited\n        a = set(sol[:i+1])\n        if sol[i] != 0:\n            a.remove(0)\n        # mark all visited nodes as invalid\n        mask[i, list(a)] = float(\"-inf\")\n\n        # mark all infeasible demand nodes as invalid\n        # this crazy implementation is due to cProfile saying \n        # list comprehension is super slow. numpy is fast.\n        c_nodes = list(set(prob) - set(sol[:i+1]) - set([0]))\n        last_route = solution_to_routes(sol[:i+1], partial=True)[-1]\n        cur_demand = get_route_demand(last_route, demands)\n        c_demands = demands[c_nodes]\n        next_demands = c_demands + cur_demand\n        sel = np.squeeze(np.argwhere(next_demands &gt; capacity))\n        infeasible_nodes = np.array(c_nodes)[sel]\n        if a == set(prob):\n            mask[i, :] = 0\n        else:\n            mask[i, infeasible_nodes.tolist()] = float(\"-inf\")\n    return mask\n</code></pre>"},{"location":"utils/#routeml.utils.get_logit_mask_vector","title":"<code>get_logit_mask_vector(sol, demands, capacity, N)</code>","text":"<p>Gets a logit mask for a given solution. Note that this only takes a full solution.</p> <p>Parameters:</p> Name Type Description Default <code>sol</code> <code>list</code> <p>the solution to mask.</p> required <code>demands</code> <code>np.ndarray</code> <p>the demands of each node.</p> required <code>capacity</code> <code>int</code> <p>the capacity of the vehicle.</p> required <code>N</code> <code>int</code> required <p>Returns:</p> Name Type Description <code>mask</code> <code>np.ndarray</code> <p>the logit mask.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_logit_mask_vector(sol, demands, capacity, N):\n\"\"\"\n    Gets a logit mask for a given solution. Note that this only takes a full solution.\n\n    Args:\n        sol (list): the solution to mask.\n        demands (np.ndarray): the demands of each node.\n        capacity (int): the capacity of the vehicle.\n        N (int):\n\n    Returns:\n        mask (np.ndarray): the logit mask.\n    \"\"\"\n    prob = set(sol)\n    mask = np.full((len(sol) - 1, len(prob)), 0.0) # mark all as valid\n    for i in range(len(sol) - 1): # NOTE this loop is 100% correct, don't change this.\n        # a is all nodes that I visited\n        a = set(sol[:i+1])\n        if sol[i] != 0:\n            a.remove(0)\n        # mark all visited nodes as invalid\n        mask[i, list(a)] = float(\"-inf\")\n\n        # mark all infeasible demand nodes as invalid\n        # this crazy implementation is due to cProfile saying \n        # list comprehension is super slow. numpy is fast.\n        c_nodes = list(set(prob) - set(sol[:i+1]) - set([0]))\n        last_route = solution_to_routes(sol[:i+1], partial=True)[-1]\n        cur_demand = get_route_demand(last_route, demands)\n        c_demands = demands[c_nodes]\n        next_demands = c_demands + cur_demand\n        sel = np.squeeze(np.argwhere(next_demands &gt; capacity))\n        infeasible_nodes = np.array(c_nodes)[sel]\n        if a == set(prob):\n            mask[i, :] = 0\n        else:\n            mask[i, infeasible_nodes.tolist()] = float(\"-inf\")\n    return mask\n</code></pre>"},{"location":"utils/#routeml.utils.get_random_solution","title":"<code>get_random_solution(N)</code>","text":"<p>Generates a random CVRP solution. Mostly for debugging purposes.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of nodes in the problem. Excluding depot.</p> required <p>Returns:</p> Name Type Description <code>lst</code> <code>list</code> <p>List containing the solution.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_random_solution(N):\n\"\"\"\n    Generates a random CVRP solution. Mostly for debugging purposes.\n\n    Args:\n        N (int): Number of nodes in the problem. Excluding depot.\n\n    Returns:\n        lst (list): List containing the solution.\n    \"\"\"\n    # Generate a random list from 0 to N\n    lst = list(range(N + 1))\n\n    # Insert 0 at the end\n    lst.append(0)\n\n    # Randomly insert 1 to 5 zeros in between\n    num_zeros = random.randint(1, 5)\n    for _ in range(num_zeros):\n        index = random.randint(1, len(lst) - 1)  # Select a random index between 1 and len(lst)-1\n        while lst[index] == 0 or lst[index-1] == 0:\n            index = random.randint(1, len(lst) - 1)  # Select a new index if adjacent elements are already 0\n        lst.insert(index, 0)\n\n    return lst\n</code></pre>"},{"location":"utils/#routeml.utils.get_route_demand","title":"<code>get_route_demand(route, demands)</code>","text":"<p>Compute the demand of a route.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>list</code> <p>List of nodes in the route.</p> required <code>demands</code> <code>list</code> <p>List containing the corresponding demands for each node.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>Demand of the route.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_route_demand(route, demands):\n\"\"\"\n    Compute the demand of a route.\n\n    Args:\n        route (list): List of nodes in the route.\n        demands (list): List containing the corresponding demands for each node.\n\n    Returns:\n        int: Demand of the route.\n    \"\"\"\n    route_demand = sum(map(lambda node: demands[node], route))\n    return route_demand\n</code></pre>"},{"location":"utils/#routeml.utils.get_submatrix","title":"<code>get_submatrix(indices, matrix, new_shape)</code>","text":"<p>Gets a submatrix from a matrix and pads it to the right and bottom with zeros.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <p>the indices to index on the matrix.</p> required <code>matrix</code> <p>the input matrix to index.</p> required <code>new_shape</code> <p>the desired shape after padding.</p> required <p>Returns:</p> Type Description <p>returns the submatrix after indexing and padding.</p> <pre><code>import numpy as np\nmatrix = np.arange(10).reshape(2, 5)\nindices = [1, 2, 3]\narray([[1, 2, 3, 0, 0, 0],\n       [6, 7, 8, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0]])\n</code></pre> Source code in <code>routeml/utils.py</code> <pre><code>def get_submatrix(indices, matrix, new_shape):\n\"\"\"\n    Gets a submatrix from a matrix and pads it to the right and bottom with zeros.\n\n    Args:\n        indices: the indices to index on the matrix.\n        matrix: the input matrix to index.\n        new_shape: the desired shape after padding.\n\n    Returns:\n        returns the submatrix after indexing and padding.\n\n    ```python\n    import numpy as np\n    matrix = np.arange(10).reshape(2, 5)\n    indices = [1, 2, 3]\n    array([[1, 2, 3, 0, 0, 0],\n           [6, 7, 8, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0]])\n    ```\n    \"\"\"\n    submatrix = matrix[:, indices]\n    return pad_matrix(submatrix, new_shape)\n</code></pre>"},{"location":"utils/#routeml.utils.is_feasible","title":"<code>is_feasible(routes, demand, capacity)</code>","text":"<p>Check if a CVRP solution is feasible.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes.</p> required <code>demand</code> <code>dict</code> <p>Dictionary containing node IDs as keys and corresponding demand as values.</p> required <code>capacity</code> <code>int</code> <p>Vehicle capacity.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the solution is feasible, False otherwise.</p> Source code in <code>routeml/utils.py</code> <pre><code>def is_feasible(routes, demand, capacity):\n\"\"\"\n    Check if a CVRP solution is feasible.\n\n    Args:\n        routes (list): List of routes.\n        demand (dict): Dictionary containing node IDs as keys and corresponding demand as values.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        bool: True if the solution is feasible, False otherwise.\n    \"\"\"\n    # Convert routes to a single solution\n    solution = routes_to_solution(routes)\n\n    # Check if each node appears only once\n    if set(solution) != set(demand.keys()):\n        return False\n\n    # Compute the demand for each route\n    for route in routes:\n        total_demand = sum(demand[node] for node in route)\n        if total_demand &gt; capacity:\n            return False\n\n    return True\n</code></pre>"},{"location":"utils/#routeml.utils.pad_matrix","title":"<code>pad_matrix(matrix, new_shape, constant_value=0)</code>","text":"<p>Pads a matrix to the right and bottom with zeros.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <p>the input matrix to pad.</p> required <code>new_shape</code> <p>the desired shape after padding.</p> required <p>Returns:</p> Type Description <p>returns the padded matrix.</p> <pre><code>import numpy as np\nmatrix = np.arange(10).reshape(2, 5)\npad_matrix(matrix, (3, 6))\narray([[0, 1, 2, 3, 4, 0],\n       [5, 6, 7, 8, 9, 0],\n       [0, 0, 0, 0, 0, 0]])\n</code></pre> Source code in <code>routeml/utils.py</code> <pre><code>def pad_matrix(matrix, new_shape, constant_value=0):\n\"\"\"\n    Pads a matrix to the right and bottom with zeros.\n\n    Args:\n        matrix: the input matrix to pad.\n        new_shape: the desired shape after padding.\n\n    Returns:\n        returns the padded matrix.\n\n    ```python\n    import numpy as np\n    matrix = np.arange(10).reshape(2, 5)\n    pad_matrix(matrix, (3, 6))\n    array([[0, 1, 2, 3, 4, 0],\n           [5, 6, 7, 8, 9, 0],\n           [0, 0, 0, 0, 0, 0]])\n    ```\n    \"\"\"\n    assert len(new_shape) == len(matrix.shape), \"new_shape and matrix dimensions must match\"\n    padding = [(0, new_dim - old_dim) if new_dim &gt; old_dim else (0, 0) for old_dim, new_dim in zip(matrix.shape, new_shape)]\n    return np.pad(matrix, padding, 'constant', constant_values=constant_value)\n</code></pre>"},{"location":"utils/#routeml.utils.parse_vrplib_file","title":"<code>parse_vrplib_file(source)</code>","text":"<p>Parses a VRPLIB file and returns a dictionary with the following keys: - name: Name of the problem. - comment: Comment of the problem. - type: Type of the problem. - dimension: Number of nodes. - edge_weight_type: Type of edge weight. - capacity: Capacity of the vehicles. - node_coords: Dict of node coordinates. - demand: Dict of node demands. - depot_ids: List of depot IDs.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>URL or path to the VRPLIB file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary with the parsed data.</p> Source code in <code>routeml/utils.py</code> <pre><code>def parse_vrplib_file(source):\n\"\"\"\n    Parses a VRPLIB file and returns a dictionary with the following keys:\n    - name: Name of the problem.\n    - comment: Comment of the problem.\n    - type: Type of the problem.\n    - dimension: Number of nodes.\n    - edge_weight_type: Type of edge weight.\n    - capacity: Capacity of the vehicles.\n    - node_coords: Dict of node coordinates.\n    - demand: Dict of node demands.\n    - depot_ids: List of depot IDs.\n\n    Args:\n        source (str): URL or path to the VRPLIB file.\n\n    Returns:\n        dict: Dictionary with the parsed data.\n    \"\"\"\n    if source.startswith('http://') or source.startswith('https://'):\n        response = requests.get(source)\n        content = response.text\n    else:\n        with open(source, 'r') as file:\n            content = file.read()\n\n    data = {}\n\n    # Extracting problem information using regex\n    name_match = re.search(r'NAME\\s*:\\s*(\\S+)', content)\n    if name_match:\n        data['name'] = name_match.group(1)\n\n    comment_match = re.search(r'COMMENT\\s*:\\s*\"(.+)\"', content)\n    if comment_match:\n        data['comment'] = comment_match.group(1)\n\n    type_match = re.search(r'TYPE\\s*:\\s*(\\S+)', content)\n    if type_match:\n        data['type'] = type_match.group(1)\n\n    dimension_match = re.search(r'DIMENSION\\s*:\\s*(\\d+)', content)\n    if dimension_match:\n        data['dimension'] = int(dimension_match.group(1))\n\n    edge_weight_type_match = re.search(r'EDGE_WEIGHT_TYPE\\s*:\\s*(\\S+)', content)\n    if edge_weight_type_match:\n        data['edge_weight_type'] = edge_weight_type_match.group(1)\n\n    capacity_match = re.search(r'CAPACITY\\s*:\\s*(\\d+)', content)\n    if capacity_match:\n        data['capacity'] = int(capacity_match.group(1))\n\n    node_coords_match = re.search(r'NODE_COORD_SECTION\\s*(.+?)\\s*DEMAND_SECTION', content, re.DOTALL)\n    if node_coords_match:\n        node_coords_str = node_coords_match.group(1).strip()\n        node_coords = []\n        for line in node_coords_str.split('\\n'):\n            node_id, x, y = re.findall(r'(\\d+)\\s+([-+]?\\d*\\.?\\d+)\\s+([-+]?\\d*\\.?\\d+)', line)[0]\n            node_coords.append([float(x), float(y)])\n        data['node_coords'] = np.array(node_coords)\n\n    # Extracting demand information\n    demand_section_match = re.search(r'DEMAND_SECTION\\s*(.+?)\\s*DEPOT_SECTION', content, re.DOTALL)\n    if demand_section_match:\n        demand_section_str = demand_section_match.group(1).strip()\n        demand = []\n        for line in demand_section_str.split('\\n'):\n            node_id, demand_val = re.findall(r'(\\d+)\\s+(-?\\d+)', line)[0]\n            demand.append(int(demand_val))\n        data['demand'] = np.array(demand)\n\n    # Extracting depot information\n    depot_section_match = re.search(r'DEPOT_SECTION\\s*(.+?)\\s*EOF', content, re.DOTALL)\n    if depot_section_match:\n        depot_section_str = depot_section_match.group(1).strip()\n        depot_ids = [int(node_id) for node_id in re.findall(r'(\\d+)\\s*[^-0-9]', depot_section_str)]\n        data['depot_ids'] = depot_ids\n\n    return data\n</code></pre>"},{"location":"utils/#routeml.utils.parse_vrplib_solution","title":"<code>parse_vrplib_solution(source)</code>","text":"<p>Parses a solution file from the VRPLIB website and returns the routes and cost.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to the solution file or URL to the solution file.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple containing the routes (list of lists) and the cost (float).</p> Source code in <code>routeml/utils.py</code> <pre><code>def parse_vrplib_solution(source):\n\"\"\"\n    Parses a solution file from the VRPLIB website and returns the routes and cost.\n\n    Args:\n        source (str): Path to the solution file or URL to the solution file.\n\n    Returns:\n        tuple: Tuple containing the routes (list of lists) and the cost (float).\n    \"\"\"\n    route_regex = re.compile(r'Route #(\\d+): (.+)')\n    cost_regex = re.compile(r'Cost ([\\d.]+)')\n\n    if source.startswith('http://') or source.startswith('https://'):\n        response = requests.get(source)\n        solution_text = response.text\n    else:\n        with open(source, 'r') as file:\n            solution_text = file.read()\n\n    routes = []\n    cost = None\n\n    lines = solution_text.strip().split('\\n')\n    for line in lines:\n        route_match = route_regex.match(line)\n        if route_match:\n            route_number = int(route_match.group(1))\n            nodes = list(map(int, route_match.group(2).split()))\n            routes.append(nodes)\n\n        cost_match = cost_regex.match(line)\n        if cost_match:\n            cost = float(cost_match.group(1))\n\n    return routes, cost\n</code></pre>"},{"location":"utils/#routeml.utils.routes_to_solution","title":"<code>routes_to_solution(routes)</code>","text":"<p>Converts a list of routes into a solution (list of routes).</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes, where each route is a list of nodes.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Solution (list of routes).</p> Source code in <code>routeml/utils.py</code> <pre><code>def routes_to_solution(routes):\n\"\"\"\n    Converts a list of routes into a solution (list of routes).\n\n    Args:\n        routes (list): List of routes, where each route is a list of nodes.\n\n    Returns:\n        list: Solution (list of routes).\n    \"\"\"\n    solution = []\n    for i, route in enumerate(routes):\n        assert route[0] == 0\n        assert route[-1] == 0\n        # Skip depot node for all routes except the first one\n        if i &gt; 0:\n            route = route[1:]\n        solution += route\n    return solution\n</code></pre>"},{"location":"utils/#routeml.utils.solution_to_adjacency_matrix","title":"<code>solution_to_adjacency_matrix(cvrp_solution)</code>","text":"<p>Converts a CVRP solution into a symmetric adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>cvrp_solution</code> <code>list</code> <p>CVRP solution (list of nodes).</p> required <p>Returns:</p> Type Description <p>np.ndarray: Symmetric adjacency matrix.</p> Source code in <code>routeml/utils.py</code> <pre><code>def solution_to_adjacency_matrix(cvrp_solution):\n\"\"\"\n    Converts a CVRP solution into a symmetric adjacency matrix.\n\n    Args:\n        cvrp_solution (list): CVRP solution (list of nodes).\n\n    Returns:\n        np.ndarray: Symmetric adjacency matrix.\n    \"\"\"\n    num_nodes = max(cvrp_solution) + 1\n    matrix = np.zeros((num_nodes, num_nodes))\n\n    for i in range(len(cvrp_solution) - 1):\n        matrix[cvrp_solution[i]][cvrp_solution[i + 1]] = 1\n        matrix[cvrp_solution[i + 1]][cvrp_solution[i]] = 1\n    return matrix\n</code></pre>"},{"location":"utils/#routeml.utils.solution_to_routes","title":"<code>solution_to_routes(solution, partial=False)</code>","text":"<p>Converts a solution (list of nodes) into a list of routes.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>list</code> <p>Solution (list of nodes).</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of routes, where each route is a list of nodes.</p> Source code in <code>routeml/utils.py</code> <pre><code>def solution_to_routes(solution, partial=False):\n\"\"\"\n    Converts a solution (list of nodes) into a list of routes.\n\n    Args:\n        solution (list): Solution (list of nodes).\n\n    Returns:\n        list: List of routes, where each route is a list of nodes.\n    \"\"\"\n    routes = []\n    route = []\n    for node in solution:\n        if node == 0 and route:\n            route.append(0)\n            routes.append(route)\n            route = []\n        route.append(node)\n    if partial:\n        routes.append(route)\n    return routes\n</code></pre>"}]}