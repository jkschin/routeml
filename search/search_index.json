{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RouteML","text":"<p>TBD!</p>"},{"location":"utils/","title":"Documentation for <code>routeml.utils</code>","text":"<p>handler: python options: show_root_heading: true show_source: true</p>"},{"location":"utils/#routeml.utils.add_depot_to_routes","title":"<code>add_depot_to_routes(routes)</code>","text":"<p>Adds the depot node to the beginning and end of each route.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes, where each route is a list of nodes.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of routes, where each route is a list of nodes, with the depot added.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If routes is not a list or a nested list.</p> Source code in <code>routeml/utils.py</code> <pre><code>def add_depot_to_routes(routes):\n\"\"\"\n    Adds the depot node to the beginning and end of each route.\n\n    Args:\n        routes (list): List of routes, where each route is a list of nodes.\n\n    Returns:\n        list: List of routes, where each route is a list of nodes, with the depot added.\n\n    Raises:\n        ValueError: If routes is not a list or a nested list.\n    \"\"\"\n    if not isinstance(routes, list):\n        raise ValueError(\"Routes must be a list\")\n\n    for route in routes:\n        if not isinstance(route, list):\n            raise ValueError(\"Routes must be a nested list\")\n\n        route.insert(0, 0)\n        route.append(0)\n\n    return routes\n</code></pre>"},{"location":"utils/#routeml.utils.get_cvrp_cost","title":"<code>get_cvrp_cost(routes_or_solution, coordinates, uchoa=False)</code>","text":"<p>Compute the total cost of a CVRP solution.</p> <p>Parameters:</p> Name Type Description Default <code>routes_or_solution</code> <code>list or solution</code> <p>List of routes or a solution.</p> required <code>coordinates</code> <code>dict</code> <p>Dictionary containing node IDs as keys and corresponding coordinates as values.</p> required <code>uchoa</code> <code>bool</code> <p>Whether to round the distances to the nearest integer. Follows the 2014 paper.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Total cost of the CVRP solution.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_cvrp_cost(routes_or_solution, coordinates, uchoa=False):\n\"\"\"\n    Compute the total cost of a CVRP solution.\n\n    Args:\n        routes_or_solution (list or solution): List of routes or a solution.\n        coordinates (dict): Dictionary containing node IDs as keys and corresponding coordinates as values.\n        uchoa (bool): Whether to round the distances to the nearest integer. Follows the 2014 paper.\n\n    Returns:\n        float: Total cost of the CVRP solution.\n    \"\"\"\n    if isinstance(routes_or_solution, list) and isinstance(routes_or_solution[0], list):\n        solution = routes_to_solution(routes_or_solution)\n    elif isinstance(routes_or_solution, list):\n        solution = routes_or_solution\n    else:\n        raise ValueError(\"Invalid input. Expected a nested list of routes or a solution.\")\n\n    total_cost = 0.0\n    for i in range(len(solution) - 1):\n        node1 = solution[i]\n        node2 = solution[i + 1]\n        coord1 = coordinates[node1]\n        coord2 = coordinates[node2]\n        distance = math.dist(coord1, coord2)\n        if uchoa:\n            distance = round(distance)\n        total_cost += distance\n\n    return total_cost\n</code></pre>"},{"location":"utils/#routeml.utils.get_route_demand","title":"<code>get_route_demand(routes, demand)</code>","text":"<p>Compute the demand of each route.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes.</p> required <p>Returns:</p> Name Type Description <code>route_demand</code> <code>list</code> <p>List containing the demand of each route.</p> Source code in <code>routeml/utils.py</code> <pre><code>def get_route_demand(routes, demand):\n\"\"\"\n    Compute the demand of each route.\n\n    Args:\n        routes (list): List of routes.\n\n    Returns:\n        route_demand (list): List containing the demand of each route.\n    \"\"\"\n    route_demands = []\n    for route in routes:\n        route_demand = 0\n        for node in route:\n            try:\n                route_demand += demand[node]\n            except KeyError:\n                raise Exception(f\"Node {node} not found in the demand dictionary\")\n        route_demands.append(route_demand)\n    return route_demands\n</code></pre>"},{"location":"utils/#routeml.utils.is_feasible","title":"<code>is_feasible(routes, demand, capacity)</code>","text":"<p>Check if a CVRP solution is feasible.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes.</p> required <code>demand</code> <code>dict</code> <p>Dictionary containing node IDs as keys and corresponding demand as values.</p> required <code>capacity</code> <code>int</code> <p>Vehicle capacity.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the solution is feasible, False otherwise.</p> Source code in <code>routeml/utils.py</code> <pre><code>def is_feasible(routes, demand, capacity):\n\"\"\"\n    Check if a CVRP solution is feasible.\n\n    Args:\n        routes (list): List of routes.\n        demand (dict): Dictionary containing node IDs as keys and corresponding demand as values.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        bool: True if the solution is feasible, False otherwise.\n    \"\"\"\n    # Convert routes to a single solution\n    solution = routes_to_solution(routes)\n\n    # Check if each node appears only once\n    if set(solution) != set(demand.keys()):\n        return False\n\n    # Compute the demand for each route\n    for route in routes:\n        total_demand = sum(demand[node] for node in route)\n        if total_demand &gt; capacity:\n            return False\n\n    return True\n</code></pre>"},{"location":"utils/#routeml.utils.parse_vrplib_file","title":"<code>parse_vrplib_file(source)</code>","text":"<p>Parses a VRPLIB file and returns a dictionary with the following keys: - name: Name of the problem. - comment: Comment of the problem. - type: Type of the problem. - dimension: Number of nodes. - edge_weight_type: Type of edge weight. - capacity: Capacity of the vehicles. - node_coords: Dict of node coordinates. - demand: Dict of node demands. - depot_ids: List of depot IDs.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>URL or path to the VRPLIB file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary with the parsed data.</p> Source code in <code>routeml/utils.py</code> <pre><code>def parse_vrplib_file(source):\n\"\"\"\n    Parses a VRPLIB file and returns a dictionary with the following keys:\n    - name: Name of the problem.\n    - comment: Comment of the problem.\n    - type: Type of the problem.\n    - dimension: Number of nodes.\n    - edge_weight_type: Type of edge weight.\n    - capacity: Capacity of the vehicles.\n    - node_coords: Dict of node coordinates.\n    - demand: Dict of node demands.\n    - depot_ids: List of depot IDs.\n\n    Args:\n        source (str): URL or path to the VRPLIB file.\n\n    Returns:\n        dict: Dictionary with the parsed data.\n    \"\"\"\n    if source.startswith('http://') or source.startswith('https://'):\n        response = requests.get(source)\n        content = response.text\n    else:\n        with open(source, 'r') as file:\n            content = file.read()\n\n    data = {}\n\n    # Extracting problem information using regex\n    name_match = re.search(r'NAME\\s*:\\s*(\\S+)', content)\n    if name_match:\n        data['name'] = name_match.group(1)\n\n    comment_match = re.search(r'COMMENT\\s*:\\s*\"(.+)\"', content)\n    if comment_match:\n        data['comment'] = comment_match.group(1)\n\n    type_match = re.search(r'TYPE\\s*:\\s*(\\S+)', content)\n    if type_match:\n        data['type'] = type_match.group(1)\n\n    dimension_match = re.search(r'DIMENSION\\s*:\\s*(\\d+)', content)\n    if dimension_match:\n        data['dimension'] = int(dimension_match.group(1))\n\n    edge_weight_type_match = re.search(r'EDGE_WEIGHT_TYPE\\s*:\\s*(\\S+)', content)\n    if edge_weight_type_match:\n        data['edge_weight_type'] = edge_weight_type_match.group(1)\n\n    capacity_match = re.search(r'CAPACITY\\s*:\\s*(\\d+)', content)\n    if capacity_match:\n        data['capacity'] = int(capacity_match.group(1))\n\n    # Extracting node coordinates\n    node_coords_match = re.search(r'NODE_COORD_SECTION\\s*(.+?)\\s*DEMAND_SECTION', content, re.DOTALL)\n    if node_coords_match:\n        node_coords_str = node_coords_match.group(1).strip()\n        node_coords = {}\n        for line in node_coords_str.split('\\n'):\n            node_id, x, y = re.findall(r'(\\d+)\\s+([-+]?\\d*\\.?\\d+)\\s+([-+]?\\d*\\.?\\d+)', line)[0]\n            node_coords[int(node_id) - 1] = (float(x), float(y))\n        data['node_coords'] = node_coords\n\n    # Extracting demand information\n    demand_section_match = re.search(r'DEMAND_SECTION\\s*(.+?)\\s*DEPOT_SECTION', content, re.DOTALL)\n    if demand_section_match:\n        demand_section_str = demand_section_match.group(1).strip()\n        demand = {}\n        for line in demand_section_str.split('\\n'):\n            node_id, demand_val = re.findall(r'(\\d+)\\s+(-?\\d+)', line)[0]\n            demand[int(node_id) - 1] = int(demand_val)\n        data['demand'] = demand\n\n    # Extracting depot information\n    depot_section_match = re.search(r'DEPOT_SECTION\\s*(.+?)\\s*EOF', content, re.DOTALL)\n    if depot_section_match:\n        depot_section_str = depot_section_match.group(1).strip()\n        depot_ids = [int(node_id) for node_id in re.findall(r'(\\d+)\\s*[^-0-9]', depot_section_str)]\n        data['depot_ids'] = depot_ids\n\n    return data\n</code></pre>"},{"location":"utils/#routeml.utils.parse_vrplib_solution","title":"<code>parse_vrplib_solution(source)</code>","text":"<p>Parses a solution file from the VRPLIB website and returns the routes and cost.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to the solution file or URL to the solution file.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>Tuple containing the routes (list of lists) and the cost (float).</p> Source code in <code>routeml/utils.py</code> <pre><code>def parse_vrplib_solution(source):\n\"\"\"\n    Parses a solution file from the VRPLIB website and returns the routes and cost.\n\n    Args:\n        source (str): Path to the solution file or URL to the solution file.\n\n    Returns:\n        tuple: Tuple containing the routes (list of lists) and the cost (float).\n    \"\"\"\n    route_regex = re.compile(r'Route #(\\d+): (.+)')\n    cost_regex = re.compile(r'Cost ([\\d.]+)')\n\n    if source.startswith('http://') or source.startswith('https://'):\n        response = requests.get(source)\n        solution_text = response.text\n    else:\n        with open(source, 'r') as file:\n            solution_text = file.read()\n\n    routes = []\n    cost = None\n\n    lines = solution_text.strip().split('\\n')\n    for line in lines:\n        route_match = route_regex.match(line)\n        if route_match:\n            route_number = int(route_match.group(1))\n            nodes = list(map(int, route_match.group(2).split()))\n            routes.append(nodes)\n\n        cost_match = cost_regex.match(line)\n        if cost_match:\n            cost = float(cost_match.group(1))\n\n    return routes, cost\n</code></pre>"},{"location":"utils/#routeml.utils.routes_to_solution","title":"<code>routes_to_solution(routes)</code>","text":"<p>Converts a list of routes into a solution (list of routes).</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list</code> <p>List of routes, where each route is a list of nodes.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Solution (list of routes).</p> Source code in <code>routeml/utils.py</code> <pre><code>def routes_to_solution(routes):\n\"\"\"\n    Converts a list of routes into a solution (list of routes).\n\n    Args:\n        routes (list): List of routes, where each route is a list of nodes.\n\n    Returns:\n        list: Solution (list of routes).\n    \"\"\"\n    solution = []\n    for i, route in enumerate(routes):\n        assert route[0] == 0\n        assert route[-1] == 0\n        # Skip depot node for all routes except the first one\n        if i &gt; 0:\n            route = route[1:]\n        solution += route\n    return solution\n</code></pre>"},{"location":"utils/#routeml.utils.solution_to_routes","title":"<code>solution_to_routes(solution)</code>","text":"<p>Converts a solution (list of nodes) into a list of routes.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>list</code> <p>Solution (list of nodes).</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of routes, where each route is a list of nodes.</p> Source code in <code>routeml/utils.py</code> <pre><code>def solution_to_routes(solution):\n\"\"\"\n    Converts a solution (list of nodes) into a list of routes.\n\n    Args:\n        solution (list): Solution (list of nodes).\n\n    Returns:\n        list: List of routes, where each route is a list of nodes.\n    \"\"\"\n    routes = []\n    route = []\n    for node in solution:\n        if node == 0 and route:\n            route.append(0)\n            routes.append(route)\n            route = []\n        route.append(node)\n    return routes\n</code></pre>"}]}